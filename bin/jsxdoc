#!/usr/bin/env node

var path  = require("path");
var NodePlatform  = require("./jsx").NodePlatform;

var Class = require("../src/Class");
eval(Class.$import("../src/compiler"));
eval(Class.$import("../src/platform"));
eval(Class.$import("../src/classdef"));
eval(Class.$import("../src/jsemitter"));
eval(Class.$import("../src/util"));

"use strict";

var FormatReST = Class.extend({
	title: Util.repeat("=", 78),

	classSection:  Util.repeat("*", 78) + "\n",
	memberSection: Util.repeat("-", 78) + "\n",

	execute: function(sourceFile) {
		var platform = new NodePlatform();
		var compiler = new Compiler(platform);
		compiler.setEmitter(new JavaScriptEmitter(platform));
		//compiler.setMode(Compiler.MODE_PARSE);

		compiler.addSourceFile(null, sourceFile);
		compiler.compile();

		this.sourceFile = sourceFile;
		this.platform = platform;
		this.compiler = compiler;

		this.writeHeader();
		this.writeBody();
		this.writeFooter();
	},

	shouldSkip: function (name) {
		return (/^_/).test(name);
	},

	formatFlags: function (flags) {
		var a = [];
		if (flags & ClassDefinition.IS_CONST) {
			a.push("const");
		}
		if (flags & ClassDefinition.IS_ABSTRACT) {
			a.push("abstract");
		}
		if (flags & ClassDefinition.IS_FINAL) {
			a.push("final");
		}
		if (flags & ClassDefinition.IS_STATIC) {
			a.push("static");
		}
		if (flags & ClassDefinition.IS_OFERRIDE) {
			a.push("override");
		}
		if (flags & ClassDefinition.IS_READONLY) {
			a.push("__readonly__");
		}
		if (a.length > 0) {
			a.push("");
		}
		return a.join(" ");
	},

	classDecl: function (classDef) {
		if (classDef.flags() & ClassDefinition.IS_INTERFACE) {
			return "interface";
		}
		else if (classDef.flags() & ClassDefinition.IS_MIXIN) {
			return "mixin";
		}
		else {
			return "class";
		}
	},

	varDecl: function (member) {
		var isConst = (member.flags() & ClassDefinition.IS_CONST) !== 0;
		return isConst ? "const" : "var";
	},

	writeHeader: function () {
		console.log(".. THIS DOCUMENT IS AUTOMATICALLY GENERATED.");
		console.log("   DO NOT EDIT THIS FILE DIRECTOLY.");
		console.log("   EDIT %s INSTEAD.", this.sourceFile);
		console.log("");

		console.log(this.title);
		console.log('Module "%s"', this.sourceFile);
		console.log(this.title);
		console.log("");
	},

	writeFooter: function () {
		console.log("");
	},

	writeBody: function () {
		this.compiler.forEachClassDef(function(parser, classDef) {
			var classNameToken = classDef.getToken();
			if(classNameToken !== null && classNameToken.getFilename() === this.sourceFile) {
				this.processClassDef(classDef);
			}
			return true;
		}.bind(this));
	},

	writeComment: function (p) {
		var lines = p.split(/\n/);
		console.log(".. " + lines.shift());
		while (lines.length) {
			console.log("    " + lines.shift());
		}
		console.log("");
	},

	writeNote: function (p) {
		var lines = p.split(/\n/);
		console.log(".. note:: " + lines.shift());
		while (lines.length) {
			console.log("    " + lines.shift());
		}
		console.log("");
	},

	writeParagraph: function (p) {
		console.log(p);
		console.log("");
	},

	writeClassSectionHeader: function (classDef) {
		var attr = this.formatFlags(classDef.flags());
		console.log(Util.format("%1%2 %3",
					[attr, this.classDecl(classDef), classDef.className()]));
		console.log(this.classSection);

		var hierarchy = [];
		classDef.forEachClassFromBase(function(baseClassDef) {
			var filename = classDef.getToken().getFilename() === baseClassDef.getToken().getFilename() ? "" : "@"+path.basename(baseClassDef.getToken().getFilename());
			hierarchy.push(Util.format("``%1%2``", [
					  baseClassDef.className(),
					  filename]));
			return true;
		}.bind(this));
		console.log("* " + hierarchy.reverse().join(" -> "));
		console.log("");

		// doc
		var doc = classDef.getDocument();
		if (doc) {
			var d = doc.getDescription();
			if (d) {
				this.writeParagraph(d);
			}
			var tag = doc.getTag();
			for (var name in tag) {
				this.writeComment("@" + name + " " + tag[name].join("\n")); // FIXME
			}
		}

		if(/^_/.test(classDef.className())) {
			this.writeNote("This is not exported by default.");
		}
	},

	writeMembers: function (classDef, predicate) {
		var members = {};

		classDef.forEachMember(function(member) {
			if (! predicate(member)) {
				return true;
			}
			var name = member.name();
			if (this.shouldSkip(name)) {
				return true;
			}
			if (! members.hasOwnProperty(name)) {
				members[name] = [];
			}
			members[name].push(member);

			return true;
		}.bind(this));

		if(members.length == 0) {
			return;
		}

		for (var name in members) {
			var memberList = members[name];

			console.log(name);
			console.log(this.memberSection);

			memberList.forEach(function (member) {
				var decl;
				if (member instanceof MemberVariableDefinition) {
					var attr = this.formatFlags(member.flags());
					decl = Util.format("``%1%2 %3 : %4``", [
						attr,
						this.varDecl(member),
						name,
						member.getType().toString()
					]);
				}
				else {
					var flags = member.flags();

					if (name === "constructor") {
						flags &= ~ClassDefinition.IS_FINAL;
					}
					else if (flags & ClassDefinition.IS_STATIC) {
						flags &= ~ClassDefinition.IS_FINAL;
					}
					var attr = this.formatFlags(flags);


					var args = member.getArguments().map(function (p) {
						return Util.format("%1 : %2",
							[p.getName().getValue(), p.getType().toString()]);
					});

					var retType = "";
					if (name !== "constructor") {
						retType = " : " + member.getReturnType().toString()
					}

					decl = Util.format("``%1function %2(%3)%4``", [
						attr,
						name,
						args.join(", "),
						retType
					]);
				}

				this.writeParagraph(decl);

				this.writeMemberDoc(member);
			}.bind(this));
		}
		console.log("");
	},

	writeMemberDoc: function (member) {
		var doc = member.getDocument();
		if (! doc) {
			return;
		}

		var d = doc.getDescription();
		if (d) {
			this.writeParagraph(d);
		}
		var tag = doc.getTag();

		var param = tag["param"];
		delete tag["param"];

		if (param && member instanceof MemberFunctionDefinition) {
			var paramMap = {};
			param.forEach(function (p) {
				var a = p.split(/\s+/);
				var paramName = a.shift();
				var paramDesc = a.join(" ");
				paramMap[paramName] = paramDesc;
			});
			member.getArguments().forEach(function (p) {
				var name = p.getName().getValue();
				console.log("``"+name+"``");
				console.log("  " + paramMap[name]);
				console.log("");
			});
		}

		var ret = tag["return"];
		delete tag["return"];
		if (ret) {
			console.log("return");
			console.log("  " + ret.join("\n  "));
			console.log("");
		}

		// FIXME process tags
		// currently the rest of the tags are embed as comments
		for (var name in tag) {
			this.writeComment("@" + name + " " + tag[name].join("\n"));
		}
	},

	processClassDef: function(classDef) {
		this.writeClassSectionHeader(classDef);

		this.writeMembers(classDef, function (member) {
			return (member.flags() & ClassDefinition.IS_STATIC) !== 0 &&
				member instanceof MemberFunctionDefinition;
		});

		this.writeMembers(classDef, function (member) {
			return (member.flags() & ClassDefinition.IS_STATIC) !== 0 &&
				member instanceof MemberVariableDefinition;
		});

		this.writeMembers(classDef, function (member) {
			return (member.flags() & ClassDefinition.IS_STATIC) === 0 &&
				member instanceof MemberFunctionDefinition;
		});

		this.writeMembers(classDef, function (member) {
			return (member.flags() & ClassDefinition.IS_STATIC) === 0 &&
				member instanceof MemberVariableDefinition;
		});

		// inherited members
		classDef.forEachClassFromBase(function(baseClassDef) {
			if (classDef === baseClassDef) {
				return false;
			}

			console.log("Inherited Members from %s", baseClassDef.className());
			console.log(this.memberSection);

			var members = [];
			baseClassDef.forEachMemberVariable(function(member) {
				if ((member.flags() & ClassDefinition.IS_STATIC) === 0) {
					return true;
				}
				if (this.shouldSkip(member.name())) {
					return true;
				}
				members.push(Util.format("``%1``", [member.name()]));
				return true;
			}.bind(this));
			if (members.length > 0) {
				console.log("* " + members.join(", "));
			}

			members = [];
			baseClassDef.forEachMemberFunction(function(member) {
				if ((member.flags() & ClassDefinition.IS_STATIC) !== 0) {
					return true;
				}
				if (this.shouldSkip(member.name())) {
					return true;
				}
				if (member.name() === "constructor") {
					return true;
				}
				members.push(Util.format("``%1()``", [member.name()]));
				return true;
			}.bind(this));
			if (members.length > 0) {
				console.log("* " + members.join(", "));
			}

			members = [];
			baseClassDef.forEachMemberVariable(function(member) {
				if ((member.flags() & ClassDefinition.IS_STATIC) !== 0) {
					return true;
				}
				if (this.shouldSkip(member.name())) {
					return true;
				}
				members.push(Util.format("``%1``", [member.name()]));
				return true;
			}.bind(this));
			if (members.length > 0) {
				console.log("* " + members.join(", "));
			}

			members = [];
			baseClassDef.forEachMemberFunction(function(member) {
				if ((member.flags() & ClassDefinition.IS_STATIC) === 0) {
					return true;
				}
				if (this.shouldSkip(member.name())) {
					return true;
				}
				members.push(Util.format("``%1()``", [member.name()]));
				return true;
			}.bind(this));
			if (members.length > 0) {
				console.log("* " + members.join(", "));
			}

			console.log("");
			return true;
		}.bind(this));
	}

});

var JSXDoc = Class.extend({
	$main: function (args) {
		var sourceFile = args[0];
		if (! sourceFile) {
			return;
		}

		var formatter = new FormatReST();
		formatter.execute(sourceFile);
	}
});

JSXDoc.main(process.argv.slice(2));


// vim: set ft=javascript:
// vim: set noexpandtab:
