#!/usr/bin/env node

var fs = require("fs");
var child_process = require("child_process");

var Class = require("../src/Class");
eval(Class.$import("../src/compiler"));
eval(Class.$import("../src/platform"));
eval(Class.$import("../src/classdef"));
eval(Class.$import("../src/jsemitter"));
eval(Class.$import("../src/util"));

"use strict";

var NodePlatform = Platform.extend({

	getRoot: function () {
		return __dirname.replace(/\/doc\/?$/, "");
	},

	fileExists: function (path) {
		try {
			fs.statSync(path);
			return true;
		} catch (e) {
			return false;
		}
	},

	getFilesInDirectory: function (path) {
		return fs.readdirSync(path);
	},

	load: function (path) {
		return fs.readFileSync(path).toString();
	},

	save: function (outputFile, content) {
		if (outputFile == null) {
			process.stdout.write(content);
		}
		else {
			fs.writeFileSync(outputFile, content);
		}
	}

});


var JSXDoc = Class.extend({
	$hr: "==================================================",
	$h1: "==================================================\n",
	$h2: "--------------------------------------------------\n",

	$main: function(args) {
		var sourceFile = args.shift();
		var title      = args.shift();
		if(!(sourceFile && title)) {
			console.log("usage: jsxdoc file title");
			return;
		}

		var platform = new NodePlatform();
		var compiler = new Compiler(platform);
		compiler.setEmitter(new JavaScriptEmitter(platform));
		//compiler.setMode(Compiler.MODE_PARSE);

		compiler.addSourceFile(null, sourceFile);
		compiler.compile();

		console.log(".. THIS DOCUMENT IS AUTOMATICALLY GENERATED.");
		console.log("   DO NOT EDIT THIS FILE DIRECTORY.");
		console.log("   EDIT %s INSTEAD.", sourceFile);
		console.log("");

		console.log(JSXDoc.hr);
		console.log('Module "%s"', title);
		console.log(JSXDoc.hr);
		console.log("");

		compiler.forEachClassDef(function(parser, classDef) {
			var classNameToken = classDef.getToken();
			if(classNameToken !== null && classNameToken.getFilename() === sourceFile) {
				JSXDoc.processClassDef(classDef);
			}
			return true;
		});

	},

	$isPrivate: function (name) {
		return (/^_/).test(name);
	},
	$varDecl: function (member) {
		var isConst = (member.flags() & ClassDefinition.IS_CONST) !== 0;
		return isConst ? "const" : "var";
	},

	$processClassDef: function(classDef) {
		// H1 class name
		console.log(classDef.className());
		console.log(JSXDoc.h1);
		console.log("");
		if(JSXDoc.isPrivate(classDef.className())) {
			console.log("This is not exported by default.");
			console.log("");
		}

		// FIXME: print class hierarchy

		// members

		var members;

		// static member variables
		members = [];
		classDef.forEachMemberVariable(function(member) {
			if((member.flags() & ClassDefinition.IS_STATIC) === 0) {
				return true;
			}
			if(JSXDoc.isPrivate(member.name())) {
				return true;
			}
			members.push(Util.format("* static %1 %2 : %3", [
						JSXDoc.varDecl(member),
						member.name(),
						member.getType().toString()]));
			return true;
		});
		if(members.length > 0) {
			console.log("Static Member Variables");
			console.log(JSXDoc.h2);
			members.forEach(function(s) {
				console.log(s);
			});
			console.log("");
		}

		// static member functions
		members = [];
		classDef.forEachMemberFunction(function(member) {
			if((member.flags() & ClassDefinition.IS_STATIC) === 0) {
				return true;
			}
			if(JSXDoc.isPrivate(member.name())) {
				return true;
			}
			var args = member.getArguments().map(function(arg) {
				var argName = arg.getName().getValue();
				var argType = arg.getType().toString();
				return Util.format("%1 : %2", [argName, argType]);
			});

			members.push(Util.format("* static function %1(%2) : %3", [
						member.name(),
						args.join(", "),
						member.getReturnType().toString()]));
			return true;
		});
		if(members.length > 0) {
			console.log("Static Member Functions");
			console.log(JSXDoc.h2);
			members.forEach(function(s) {
				console.log(s);
			});
			console.log("");
		}

		// member variables
		members = [];
		classDef.forEachMemberVariable(function(member) {
			if((member.flags() & ClassDefinition.IS_STATIC) !== 0) {
				return true;
			}
			if(JSXDoc.isPrivate(member.name())) {
				return true;
			}
			members.push(Util.format("* %1 %2 : %3", [
						JSXDoc.varDecl(member),
						member.name(),
						member.getType().toString()]));
			return true;
		});
		if(members.length > 0) {
			console.log("Member Variables");
			console.log(JSXDoc.h2);
			members.forEach(function(s) {
				console.log(s);
			});
			console.log("");
		}

		// member functions
		members = [];
		classDef.forEachMemberFunction(function(member) {
			if((member.flags() & ClassDefinition.IS_STATIC) !== 0) {
				return true;
			}
			if(JSXDoc.isPrivate(member.name())) {
				return true;
			}
			var args = member.getArguments().map(function(arg) {
				var argName = arg.getName().getValue();
				var argType = arg.getType().toString();
				return Util.format("%1 : %2", [argName, argType]);
			});

			members.push(Util.format("* function %1(%2) : %3", [
						member.name(),
						args.join(", "),
						member.getReturnType().toString()]));
			return true;
		});
		if(members.length > 0) {
			console.log("Member Functions");
			console.log(JSXDoc.h2);
			members.forEach(function(s) {
				console.log(s);
			});
			console.log("");
		}

		// inherited members
		classDef.extendClassDef() && classDef.forEachClassFromBase(function(baseClassDef) {
			if(classDef === baseClassDef) {
				return false;
			}

			console.log("Inherited Members from %s", baseClassDef.className());
			console.log(JSXDoc.h2);

			var members = [];
			baseClassDef.forEachMemberVariable(function(member) {
				if((member.flags() & ClassDefinition.IS_STATIC) === 0) {
					return true;
				}
				if(JSXDoc.isPrivate(member.name())) {
					return true;
				}
				members.push(member.name());
				return true;
			});
			if(members.length > 0) {
				console.log("* static member variables: %s", members.join(", "));
			}

			members = [];
			baseClassDef.forEachMemberFunction(function(member) {
				if((member.flags() & ClassDefinition.IS_STATIC) !== 0) {
					return true;
				}
				if(JSXDoc.isPrivate(member.name())) {
					return true;
				}
				members.push(member.name() + "()");
				return true;
			});
			if(members.length > 0) {
				console.log("* member functions: %s", members.join(", "));
			}

			members = [];
			baseClassDef.forEachMemberVariable(function(member) {
				if((member.flags() & ClassDefinition.IS_STATIC) !== 0) {
					return true;
				}
				if(JSXDoc.isPrivate(member.name())) {
					return true;
				}
				members.push(member.name());
				return true;
			});
			if(members.length > 0) {
				console.log("* member variables: %s", members.join(", "));
			}

			members = [];
			baseClassDef.forEachMemberFunction(function(member) {
				if((member.flags() & ClassDefinition.IS_STATIC) === 0) {
					return true;
				}
				if(JSXDoc.isPrivate(member.name())) {
					return true;
				}
				members.push(member.name() + "()");
				return true;
			});
			if(members.length > 0) {
				console.log("* member functions: %s", members.join(", "));
			}

			console.log("");
			return true;
		});
	}

});

JSXDoc.main(process.argv.slice(2));


// vim: set ft=javascript:
// vim: set noexpandtab:
